# [2개이하로다른비트]

[](https://school.programmers.co.kr/learn/courses/30/lessons/77885)

###### 문제 설명

양의 정수 `x`에 대한 함수 `f(x)`를 다음과 같이 정의합니다.

-   `x`보다 크고 `x`와 **비트가 1~2개 다른** 수들 중에서 제일 작은 수

예를 들어,

-   `f(2) = 3` 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

| 수 | 비트 | 다른 비트의 개수 |
| --- | --- | --- |
| 2 | `000...0010` |  |
| 3 | `000...0011` | 1 |

-   `f(7) = 11` 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

| 수 | 비트 | 다른 비트의 개수 |
| --- | --- | --- |
| 7 | `000...0111` |  |
| 8 | `000...1000` | 4 |
| 9 | `000...1001` | 3 |
| 10 | `000...1010` | 3 |
| 11 | `000...1011` | 2 |

정수들이 담긴 배열 `numbers`가 매개변수로 주어집니다. `numbers`의 모든 수들에 대하여 각 수의 `f` 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.

___

##### 제한사항

-   1 ≤ `numbers`의 길이 ≤ 100,000
-   0 ≤ `numbers`의 모든 수 ≤ 10<sup>15</sup>

___

##### 입출력 예

| numbers | result |
| --- | --- |
| `[2,7]` | `[3,11]` |

___

##### 입출력 예 설명

**입출력 예 #1**

-   문제 예시와 같습니다.

## 첫번째 풀이

```javascript
function solution(numbers) {
    return numbers.map(number => {
        if (number%2===0) return number+1;
        
        let bitStr = '0' + number.toString(2)
        const targetIndex = bitStr.lastIndexOf('01')
        bitStr = bitStr.slice(0,targetIndex) + '10' + bitStr.slice(targetIndex+2, bitStr.length)
        
        return parseInt(bitStr,2)
    });
}
```
- 처음에 중첩 반복문으로 풀려고 시도하다가, 제한사항이 너무 큰 배열을 줄 수도 있다는 생각에 변경하였다.
    - 분명히 런타임오류가 뜰것이라 생각했기 때문
- 2진수의 패턴을 알아야 풀이가 쉬운 문제라고 생각한다.
    - 짝수라면 0으로끝나고, 다음 홀수가 한개만 변한 상태이므로 항상 다음 수를 리턴해주면된다.
    - 홀수라면 '01'을 찾아야 한다.
        - 홀수일때 01을 찾아 10으로 바꾸면 그게 문제에서 원하는 비트이기 때문
        - ![image](https://github.com/user-attachments/assets/756a91f8-e345-4405-90d0-cfe665e7a968)